---
source: macro/src/lib.rs
expression: "rustfmt_code(&expand_grammar(parse_quote!\n{\n    mod grammar\n    {\n        use rust_sitter::{Rule, Spanned}; #[derive(Rule)] #[language] pub\n        struct NumberList { numbers: Vec<Spanned<Number>>, } #[derive(Rule)]\n        pub struct Number { #[leaf(re(r\"\\d+\"))] v: i32 } #[derive(Rule)]\n        #[extra] struct Whitespace\n        { #[leaf(pattern(r\"\\s\"))] _whitespace: (), }\n    }\n}).to_token_stream().to_string())"
---
mod grammar {
    use rust_sitter::{Rule, Spanned};
    impl ::rust_sitter::rule::Language for NumberList {
        fn produce_grammar() -> String {
            String::new()
        }
        fn language() -> ::rust_sitter::tree_sitter::Language {
            unsafe extern "C" {
                fn tree_sitter_NumberList() -> ::rust_sitter::tree_sitter::Language;
            }
            unsafe { tree_sitter_NumberList() }
        }
        #[doc = r" Parse an input string according to the grammar. Returns either any parsing errors that happened, or a"]
        #[doc = "[`NumberList`]"]
        #[doc = r" instance containing the parsed structured data."]
        fn parse(input: &str) -> ::rust_sitter::ParseResult<Self> {
            ::rust_sitter::__private::parse(input, Self::language)
        }
    }
    impl ::rust_sitter::Extract for NumberList {
        type Output = Self;
        type LeafFn = ();
        #[allow(non_snake_case)]
        fn extract<'tree>(
            ctx: &mut ::rust_sitter::extract::ExtractContext,
            node: Option<::rust_sitter::tree_sitter::Node<'tree>>,
            source: &[u8],
            _l: Self::LeafFn,
        ) -> Result<Self, ::rust_sitter::extract::ExtractError<'tree>> {
            let node = node.ok_or_else(|| ::rust_sitter::error::ExtractError::missing_node(ctx))?;
            ::rust_sitter::__private::extract_struct_or_variant(
                stringify!(NumberList),
                node,
                move |state| {
                    Ok(NumberList {
                        numbers: ::rust_sitter::__private::extract_field::<Vec<Spanned<Number>>, _>(
                            ::rust_sitter::extract::BaseExtractor::default(),
                            (),
                            state,
                            ::rust_sitter::extract::ExtractFieldContext::new(1u32, true, |state| {
                                match state {
                                    0u32 => ::rust_sitter::extract::ExtractFieldState::Str(
                                        "List_NumberList_numbers",
                                        true,
                                        false,
                                    ),
                                    1u32 => ::rust_sitter::extract::ExtractFieldState::Complete,
                                    _ => ::rust_sitter::extract::ExtractFieldState::Overflow,
                                }
                            }),
                            source,
                            "numbers",
                        )?,
                    })
                },
            )
        }
    }
    impl ::rust_sitter::rule::Rule for NumberList {
        fn produce_ast() -> String {
            String::new()
        }
        fn rule_name() -> &'static str {
            "NumberList"
        }
    }
    impl ::rust_sitter::Extract for Number {
        type Output = Self;
        type LeafFn = ();
        #[allow(non_snake_case)]
        fn extract<'tree>(
            ctx: &mut ::rust_sitter::extract::ExtractContext,
            node: Option<::rust_sitter::tree_sitter::Node<'tree>>,
            source: &[u8],
            _l: Self::LeafFn,
        ) -> Result<Self, ::rust_sitter::extract::ExtractError<'tree>> {
            let node = node.ok_or_else(|| ::rust_sitter::error::ExtractError::missing_node(ctx))?;
            ::rust_sitter::__private::extract_struct_or_variant(
                stringify!(Number),
                node,
                move |state| {
                    Ok(Number {
                        v: ::rust_sitter::__private::extract_field::<i32, _>(
                            ::rust_sitter::extract::BaseExtractor::default(),
                            (),
                            state,
                            ::rust_sitter::extract::ExtractFieldContext::new(
                                0u32,
                                false,
                                |state| match state {
                                    0u32 => ::rust_sitter::extract::ExtractFieldState::Complete,
                                    _ => ::rust_sitter::extract::ExtractFieldState::Overflow,
                                },
                            ),
                            source,
                            "v",
                        )?,
                    })
                },
            )
        }
    }
    impl ::rust_sitter::rule::Rule for Number {
        fn produce_ast() -> String {
            String::new()
        }
        fn rule_name() -> &'static str {
            "Number"
        }
    }
    impl ::rust_sitter::Extract for Whitespace {
        type Output = Self;
        type LeafFn = ();
        #[allow(non_snake_case)]
        fn extract<'tree>(
            ctx: &mut ::rust_sitter::extract::ExtractContext,
            node: Option<::rust_sitter::tree_sitter::Node<'tree>>,
            source: &[u8],
            _l: Self::LeafFn,
        ) -> Result<Self, ::rust_sitter::extract::ExtractError<'tree>> {
            let node = node.ok_or_else(|| ::rust_sitter::error::ExtractError::missing_node(ctx))?;
            ::rust_sitter::__private::extract_struct_or_variant(
                stringify!(Whitespace),
                node,
                move |state| {
                    Ok(Whitespace {
                        _whitespace: ::rust_sitter::__private::extract_field::<(), _>(
                            ::rust_sitter::extract::BaseExtractor::default(),
                            (),
                            state,
                            ::rust_sitter::extract::ExtractFieldContext::new(
                                0u32,
                                false,
                                |state| match state {
                                    0u32 => ::rust_sitter::extract::ExtractFieldState::Complete,
                                    _ => ::rust_sitter::extract::ExtractFieldState::Overflow,
                                },
                            ),
                            source,
                            "_whitespace",
                        )?,
                    })
                },
            )
        }
    }
    impl ::rust_sitter::rule::Rule for Whitespace {
        fn produce_ast() -> String {
            String::new()
        }
        fn rule_name() -> &'static str {
            "Whitespace"
        }
    }
}

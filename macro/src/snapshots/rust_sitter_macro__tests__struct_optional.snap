---
source: macro/src/lib.rs
expression: "rustfmt_code(&expand_grammar(parse_quote!\n{\n    mod grammar\n    {\n        #[derive(rust_sitter::Rule)] #[language] pub struct Language\n        { #[leaf(re(r\"\\d+\"))] v: Option<i32>, t: Option<Number>, }\n        #[derive(rust_sitter::Rule)] pub struct Number\n        { #[leaf(re(r\"\\d+\"))] v: i32 }\n    }\n}).to_token_stream().to_string())"
---
mod grammar {
    impl ::rust_sitter::rule::Language for Language {
        fn produce_grammar() -> String {
            String::new()
        }
        fn language() -> ::rust_sitter::tree_sitter::Language {
            unsafe extern "C" {
                fn tree_sitter_Language() -> ::rust_sitter::tree_sitter::Language;
            }
            unsafe { tree_sitter_Language() }
        }
        #[doc = r" Parse an input string according to the grammar. Returns either any parsing errors that happened, or a"]
        #[doc = "[`Language`]"]
        #[doc = r" instance containing the parsed structured data."]
        fn parse(input: &str) -> ::rust_sitter::ParseResult<Self> {
            ::rust_sitter::__private::parse(input, Self::language)
        }
    }
    impl ::rust_sitter::Extract<Language> for Language {
        type LeafFn<'a> = ();
        #[allow(non_snake_case)]
        fn extract<'a, 'tree>(
            ctx: &mut ::rust_sitter::extract::ExtractContext<'_>,
            node: Option<::rust_sitter::tree_sitter::Node<'tree>>,
            source: &[u8],
            _leaf_fn: Option<Self::LeafFn<'a>>,
        ) -> Result<Self, ::rust_sitter::extract::ExtractError<'tree>> {
            let node = node.expect("no node found");
            ::rust_sitter::__private::extract_struct_or_variant(node, move |state| {
                Ok(Language {
                    v: {
                        ::rust_sitter::__private::extract_field::<Option<i32>, _>(
                            state, source, "v", None,
                        )
                    }?,
                    t: {
                        ::rust_sitter::__private::extract_field::<Option<Number>, _>(
                            state, source, "t", None,
                        )
                    }?,
                })
            })
        }
    }
    impl ::rust_sitter::rule::Rule<Language> for Language {
        fn produce_ast() -> String {
            String::new()
        }
        fn rule_name() -> &'static str {
            "Language"
        }
    }
    impl ::rust_sitter::Extract<Number> for Number {
        type LeafFn<'a> = ();
        #[allow(non_snake_case)]
        fn extract<'a, 'tree>(
            ctx: &mut ::rust_sitter::extract::ExtractContext<'_>,
            node: Option<::rust_sitter::tree_sitter::Node<'tree>>,
            source: &[u8],
            _leaf_fn: Option<Self::LeafFn<'a>>,
        ) -> Result<Self, ::rust_sitter::extract::ExtractError<'tree>> {
            let node = node.expect("no node found");
            ::rust_sitter::__private::extract_struct_or_variant(node, move |state| {
                Ok(Number {
                    v: {
                        ::rust_sitter::__private::extract_field::<i32, _>(state, source, "v", None)
                    }?,
                })
            })
        }
    }
    impl ::rust_sitter::rule::Rule<Number> for Number {
        fn produce_ast() -> String {
            String::new()
        }
        fn rule_name() -> &'static str {
            "Number"
        }
    }
}

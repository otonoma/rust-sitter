---
source: macro/src/lib.rs
expression: "rustfmt_code(&expand_grammar(parse_quote!\n{\n    mod grammar\n    {\n        #[derive(rust_sitter::Rule)] #[language] pub enum Expression\n        {\n            Number(#[leaf(pattern(r\"\\d+\"))] i32), #[prec_left(1)]\n            Sub(Box<Expression>, #[leaf(\"-\")] (), Box<Expression>),\n        }\n    }\n}).to_token_stream().to_string())"
---
mod grammar {
    impl ::rust_sitter::rule::Language for Expression {
        fn produce_grammar() -> String {
            String::new()
        }
        fn language() -> ::rust_sitter::tree_sitter::Language {
            unsafe extern "C" {
                fn tree_sitter_Expression() -> ::rust_sitter::tree_sitter::Language;
            }
            unsafe { tree_sitter_Expression() }
        }
        #[doc = r" Parse an input string according to the grammar. Returns either any parsing errors that happened, or a"]
        #[doc = "[`Expression`]"]
        #[doc = r" instance containing the parsed structured data."]
        fn parse(input: &str) -> ::rust_sitter::ParseResult<Self> {
            ::rust_sitter::__private::parse(input, Self::language)
        }
    }
    impl ::rust_sitter::Extract for Expression {
        type Output = Self;
        type LeafFn = ();
        #[allow(non_snake_case)]
        fn extract<'tree>(
            ctx: &mut ::rust_sitter::extract::ExtractContext,
            node: Option<::rust_sitter::tree_sitter::Node<'tree>>,
            source: &[u8],
            _l: Self::LeafFn,
        ) -> Result<Self, ::rust_sitter::extract::ExtractError<'tree>> {
            let node = node.ok_or_else(|| ::rust_sitter::error::ExtractError::missing_node(ctx))?;
            let mut cursor = node.walk();
            if !cursor.goto_first_child() {
                return Err(::rust_sitter::error::ExtractError::missing_node(ctx));
            }
            loop {
                let node = cursor.node();
                match node.kind() {
                    "Expression_Number" => {
                        return ::rust_sitter::__private::extract_struct_or_variant(
                            stringify!(Expression::Number),
                            node,
                            move |state| {
                                Ok(Expression::Number(
                                    ::rust_sitter::__private::extract_field::<i32, _>(
                                        ::rust_sitter::extract::BaseExtractor::default(),
                                        (),
                                        state,
                                        ::rust_sitter::extract::ExtractFieldContext::new(
                                            0u32,
                                            false,
                                            |state| {
                                                match state { 0u32 => :: rust_sitter :: extract :: ExtractFieldState :: Complete , _ => :: rust_sitter :: extract :: ExtractFieldState :: Overflow , }
                                            },
                                        ),
                                        source,
                                        "0",
                                    )?,
                                ))
                            },
                        )
                    }
                    "Expression_Sub" => {
                        return ::rust_sitter::__private::extract_struct_or_variant(
                            stringify!(Expression::Sub),
                            node,
                            move |state| {
                                Ok(Expression::Sub(
                                    ::rust_sitter::__private::extract_field::<Box<Expression>, _>(
                                        ::rust_sitter::extract::BaseExtractor::default(),
                                        (),
                                        state,
                                        ::rust_sitter::extract::ExtractFieldContext::new(
                                            1u32,
                                            false,
                                            |state| {
                                                match state { 0u32 => :: rust_sitter :: extract :: ExtractFieldState :: Str ("Expression" , true , false) , 1u32 => :: rust_sitter :: extract :: ExtractFieldState :: Complete , _ => :: rust_sitter :: extract :: ExtractFieldState :: Overflow , }
                                            },
                                        ),
                                        source,
                                        "0",
                                    )?,
                                    ::rust_sitter::__private::extract_field::<(), _>(
                                        ::rust_sitter::extract::BaseExtractor::default(),
                                        (),
                                        state,
                                        ::rust_sitter::extract::ExtractFieldContext::new(
                                            1u32,
                                            false,
                                            |state| {
                                                match state { 0u32 => :: rust_sitter :: extract :: ExtractFieldState :: Str ("-" , false , false) , 1u32 => :: rust_sitter :: extract :: ExtractFieldState :: Complete , _ => :: rust_sitter :: extract :: ExtractFieldState :: Overflow , }
                                            },
                                        ),
                                        source,
                                        "1",
                                    )?,
                                    ::rust_sitter::__private::extract_field::<Box<Expression>, _>(
                                        ::rust_sitter::extract::BaseExtractor::default(),
                                        (),
                                        state,
                                        ::rust_sitter::extract::ExtractFieldContext::new(
                                            1u32,
                                            false,
                                            |state| {
                                                match state { 0u32 => :: rust_sitter :: extract :: ExtractFieldState :: Str ("Expression" , true , false) , 1u32 => :: rust_sitter :: extract :: ExtractFieldState :: Complete , _ => :: rust_sitter :: extract :: ExtractFieldState :: Overflow , }
                                            },
                                        ),
                                        source,
                                        "2",
                                    )?,
                                ))
                            },
                        )
                    }
                    k => {
                        if !cursor.goto_next_sibling() {
                            return Err(::rust_sitter::error::ExtractError::missing_enum(ctx));
                        }
                    }
                }
            }
        }
    }
    impl ::rust_sitter::rule::Rule for Expression {
        const RULE_NAME: &'static str = "Expression";
        fn produce_ast() -> String {
            String::new()
        }
    }
}
